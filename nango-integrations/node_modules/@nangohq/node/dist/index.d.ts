import type { ListRecordsRequestConfig, Metadata, MetadataChangeResponse, NangoProps, ProxyConfiguration, StandardNangoConfig, SyncStatusResponse, UpdateSyncFrequencyResponse } from './types.js';
import type { ApiKeyCredentials, ApiPublicConnection, ApiPublicIntegration, AppCredentials, AppStoreCredentials, BasicApiCredentials, BillCredentials, CustomCredentials, DeleteSyncVariant, GetPublicConnection, GetPublicConnections, GetPublicEnvironmentVariables, GetPublicIntegration, GetPublicProvider, GetPublicProviders, JwtCredentials, NangoRecord, OAuth1Token, OAuth2ClientCredentials, OpenAIFunction, PatchPublicConnection, PatchPublicIntegration, PostConnectSessions, PostPublicConnectSessionsReconnect, PostPublicIntegration, PostPublicTrigger, PostSyncVariant, SignatureCredentials, TbaCredentials, TwoStepCredentials, UnauthCredentials } from '@nangohq/types';
import type { AxiosInstance, AxiosResponse, InternalAxiosRequestConfig } from 'axios';
export declare const prodHost = "https://api.nango.dev";
export * from './types.js';
export { getUserAgent } from './utils.js';
export interface AdminAxiosProps {
    userAgent?: string;
    interceptors?: {
        request?: (config: InternalAxiosRequestConfig) => InternalAxiosRequestConfig;
        response?: {
            onFulfilled: (value: AxiosResponse) => AxiosResponse | Promise<AxiosResponse>;
            onRejected?: (error: unknown) => unknown;
        };
    };
}
export declare class Nango {
    serverUrl: string;
    secretKey: string;
    connectionId?: string;
    providerConfigKey?: string;
    isSync: boolean;
    dryRun: boolean;
    isScript: boolean;
    activityLogId?: string | undefined;
    userAgent: string;
    http: AxiosInstance;
    constructor(config: NangoProps, { userAgent, interceptors }?: AdminAxiosProps);
    /****************
     * Providers
     *****************/
    /**
     * Returns a list of all available providers
     * @returns A promise that resolves with an object containing an array of providers
     */
    listProviders(queries: GetPublicProviders['Querystring']): Promise<GetPublicProviders['Success']>;
    /**
     * Returns a specific provider
     * @returns A promise that resolves with an object containing a provider
     */
    getProvider(params: GetPublicProvider['Params']): Promise<GetPublicProvider['Success']>;
    /**
     * =======
     * INTEGRATIONS
     *      LIST
     *      GET
     *      CREATE
     *      UPDATE
     *      DELETE
     * =======
     */
    /**
     * Returns a list of integrations
     * @returns A promise that resolves with an object containing an array of integrations
     */
    listIntegrations(): Promise<{
        configs: ApiPublicIntegration[];
    }>;
    getIntegration(params: GetPublicIntegration['Params'], queries?: GetPublicIntegration['Querystring']): Promise<GetPublicIntegration['Success']>;
    createIntegration(body: PostPublicIntegration['Body']): Promise<PostPublicIntegration['Success']>;
    updateIntegration(params: PatchPublicIntegration['Params'], body: PatchPublicIntegration['Body']): Promise<PatchPublicIntegration['Success']>;
    /**
     * Deletes an integration with the specified configuration key
     * @param providerConfigKey - The key identifying the provider configuration on Nango
     * @returns A promise that resolves with the response from the server
     */
    deleteIntegration(providerConfigKey: string): Promise<AxiosResponse<void>>;
    /**
     * =======
     * CONNECTIONS
     *      LIST
     *      GET
     *      IMPORT / CREATE -- DEPRECATED use REST API
     *      GET TOKEN
     *      GET RAW TOKEN
     *      GET METADATA
     *      SET METADATA
     *      DELETE
     * =======
     */
    /**
     * Returns a list of connections, optionally filtered by connection ID
     * @param connectionId - Optional. Will exactly match a given connectionId. Can return multiple connections with the same ID across integrations
     * @param search - Optional. Search connections. Will search in connection ID or end user profile.
     * @returns A promise that resolves with an array of connection objects
     */
    listConnections(connectionId?: string, search?: string, queries?: Omit<GetPublicConnections['Querystring'], 'connectionId' | 'search'>): Promise<GetPublicConnections['Success']>;
    /**
     * Returns a list of connections using object parameter syntax
     * @param params - Object containing optional filter parameters
     * @returns A promise that resolves with an array of connection objects
     */
    listConnections(params: {
        connectionId?: string;
        userId?: string;
        integrationId?: string | string[];
        tags?: Record<'displayName' | 'email', string>;
        limit?: number;
    }): Promise<GetPublicConnections['Success']>;
    /**
     * Returns a connection object, which also contains access credentials and full credentials payload
     * @param providerConfigKey - The integration ID used to create the connection (i.e Unique Key)
     * @param connectionId - This is the unique connection identifier used to identify this connection
     * @param forceRefresh - Optional. When set to true, this obtains a new access token from the provider before the current token has expired
     * @param refreshToken - Optional. When set to true, this returns the refresh token as part of the response
     * @param refreshGithubAppJwtToken - Optional. When set to true, this will refresh the JWT token for GitHub App / Github App OAuth connections
     * @returns A promise that resolves with a connection object
     */
    getConnection(providerConfigKey: string, connectionId: string, forceRefresh?: boolean, refreshToken?: boolean, refreshGithubAppJwtToken?: boolean): Promise<GetPublicConnection['Success']>;
    /**
     * Patch a connection
     * @param params - The parameters for the connection
     * @param body - The body of the connection
     * @returns The response from the server
     */
    patchConnection(params: PatchPublicConnection['QP'], body: PatchPublicConnection['Body']): Promise<PatchPublicConnection['Success']>;
    /**
     * For OAuth 2: returns the access token directly as a string
     * For OAuth 2: If you want to obtain a new refresh token from the provider before the current token has expired,
     * you can set the forceRefresh argument to true
     * For OAuth 1: returns an object with 'oAuthToken' and 'oAuthTokenSecret' fields
     * @param providerConfigKey - The integration ID used to create the connection (i.e Unique Key)
     * @param connectionId - This is the unique connection identifier used to identify this connection
     * @param forceRefresh - Optional. When set to true, this obtains a new access token from the provider before the current token has expired
     * @param refreshGithubAppJwtToken - Optional. When set to true, this will refresh the JWT token for GitHub App / Github App OAuth connections
     */
    getToken(providerConfigKey: string, connectionId: string, forceRefresh?: boolean, refreshGithubAppJwtToken?: boolean): Promise<string | OAuth1Token | BasicApiCredentials | ApiKeyCredentials | AppCredentials | OAuth2ClientCredentials | AppStoreCredentials | UnauthCredentials | CustomCredentials | TbaCredentials | JwtCredentials | BillCredentials | TwoStepCredentials | SignatureCredentials>;
    /**
     * Get the full (fresh) credentials payload returned by the external API,
     * which also contains access credentials
     * @param providerConfigKey - The integration ID used to create the connection (i.e Unique Key)
     * @param connectionId - This is the unique connection identifier used to identify this connection
     * @param forceRefresh - Optional. When set to true, this obtains a new access token from the provider before the current token has expired
     * @param refreshGithubAppJwtToken - Optional. When set to true, this will refresh the JWT token for GitHub App / Github App OAuth connections
     * @returns A promise that resolves with the raw token response
     */
    getRawTokenResponse<T = Record<string, any>>(providerConfigKey: string, connectionId: string, forceRefresh?: boolean, refreshGithubAppJwtToken?: boolean): Promise<T>;
    /**
     * Retrieves metadata for a given provider configuration key and connection ID
     * @param providerConfigKey - The key identifying the provider configuration on Nango
     * @param connectionId - The ID of the connection for which to retrieve metadata
     * @returns A promise that resolves with the retrieved metadata
     */
    getMetadata<T = Metadata>(providerConfigKey: string, connectionId: string): Promise<T>;
    /**
     * Sets custom metadata for a connection
     * @param providerConfigKey - The key identifying the provider configuration on Nango
     * @param connectionId - The ID(s) of the connection(s) for which to set metadata
     * @param metadata - The custom metadata to set
     * @returns A promise that resolves with the Axios response from the server
     */
    setMetadata(providerConfigKey: string, connectionId: string | string[], metadata: Metadata): Promise<AxiosResponse<MetadataChangeResponse>>;
    /**
     * Edits custom metadata for a connection, only overriding specified properties, not the entire metadata
     * @param providerConfigKey - The key identifying the provider configuration on Nango
     * @param connectionId - The ID(s) of the connection(s) for which to update metadata
     * @param metadata - The custom metadata to update
     * @returns A promise that resolves with the Axios response from the server
     */
    updateMetadata(providerConfigKey: string, connectionId: string | string[], metadata: Metadata): Promise<AxiosResponse<MetadataChangeResponse>>;
    /**
     * Deletes a specific connection
     * @param providerConfigKey - The key identifying the provider configuration on Nango
     * @param connectionId - The ID of the connection to be deleted
     * @returns A promise that resolves with the Axios response from the server
     */
    deleteConnection(providerConfigKey: string, connectionId: string): Promise<AxiosResponse<void>>;
    /**
     * =======
     * SCRIPTS
     *      CONFIG
     * =======
     */
    /**
     * Retrieves the configuration for all integration scripts
     * @param format The format to return the configuration in ('nango' | 'openai')
     * @returns A promise that resolves with an array of configuration objects for all integration scripts
     */
    getScriptsConfig(format?: 'nango' | 'openai'): Promise<StandardNangoConfig[] | {
        data: OpenAIFunction[];
    }>;
    /**
     * =======
     * SYNCS
     *      GET RECORDS
     *      DELETE RECORDS
     *      TRIGGER
     *      START
     *      PAUSE
     *      STATUS
     *      GET ENVIRONMENT VARIABLES
     * =======
     */
    /**
     * Returns the synced data, ordered by modification date ascending
     * If some records are updated while you paginate through this endpoint, you might see these records multiple times
     * @param config - Configuration object for listing records
     * @returns A promise that resolves with an object containing an array of records and a cursor for pagination
     */
    listRecords<T extends Record<string, any> = Record<string, any>>(config: ListRecordsRequestConfig): Promise<{
        records: NangoRecord<T>[];
        next_cursor: string | null;
    }>;
    /**
     * Prunes records payload from Nangoâ€™s cache only, for a given model and connection, up to a specified cursor
     * Payload is emptied but record metadata is retained. Payload can be restored by re-syncing the data.
     * @param providerConfigKey - The key identifying the provider configuration on Nango
     * @param connectionId - The ID of the connection for which to prune records
     * @param model - The model from which to prune records
     * @param variant - An optional variant of the model from which to prune records
     * @param untilCursor - The cursor up to which records should be prune
     * @param limit - An optional limit on the number of records to prune in this operation
     * @returns A promise that resolves with an object containing the count of pruned records and a flag indicating if more records are available for pruning
     */
    pruneRecords({ providerConfigKey, connectionId, model, variant, untilCursor, limit }: {
        providerConfigKey: string;
        connectionId: string;
        model: string;
        variant?: string;
        untilCursor: string;
        limit?: number;
    }): Promise<{
        count: number;
        has_more: boolean;
    }>;
    /**
     * Triggers an additional, one-off execution of specified sync(s) for a given connection or all applicable connections if no connection is specified
     * @param providerConfigKey - The key identifying the provider configuration on Nango
     * @param syncs - An optional array of sync names or sync names/variants to trigger. If empty, all applicable syncs will be triggered
     * @param connectionId - An optional ID of the connection for which to trigger the syncs. If not provided, syncs will be triggered for all applicable connections
     * @param syncMode - An optional flag indicating whether to perform an incremental or full resync. Defaults to 'incremental`
     * @returns A promise that resolves when the sync trigger request is sent
     */
    triggerSync(providerConfigKey: string, syncs?: (string | {
        name: string;
        variant: string;
    })[], connectionId?: string, syncMode?: PostPublicTrigger['Body']['sync_mode'] | boolean): Promise<void>;
    /**
     * Starts the schedule of specified sync(s) for a given connection or all applicable connections if no connection is specified. Upon starting the schedule, the sync will execute immediately and then continue to run at the specified frequency. If the schedule was already started, this will have no effect.
     * @param providerConfigKey - The key identifying the provider configuration on Nango
     * @param syncs - An optional array of sync names or sync objects to start. If empty, all applicable syncs will be started
     * @param connectionId - An optional ID of the connection for which to start the syncs. If not provided, syncs will be started for all applicable connections
     * @returns A promise that resolves when the sync start request is sent
     */
    startSync(providerConfigKey: string, syncs: (string | {
        name: string;
        variant: string;
    })[], connectionId?: string): Promise<void>;
    /**
     * Pauses the schedule of specified sync(s) for a given connection or all applicable connections
     * @param providerConfigKey -The key identifying the provider configuration on Nango
     * @param syncs - An optional array of sync names or sync objects to pause. If empty, all applicable syncs will be paused
     * @param connectionId - An optional ID of the connection for which to pause the syncs. If not provided, syncs will be paused for all applicable connections
     * @returns A promise that resolves when the sync pause request is sent
     */
    pauseSync(providerConfigKey: string, syncs: (string | {
        name: string;
        variant: string;
    })[], connectionId?: string): Promise<void>;
    /**
     * Get the status of specified sync(s) for a given connection or all applicable connections
     * @param providerConfigKey - The key identifying the provider configuration on Nango
     * @param syncs - An array of sync names or sync objects to get status for, or '*' to get status for all syncs
     * @param connectionId - An optional ID of the connection for which to get sync status. If not provided, status for all applicable connections will be retrieved
     * @returns A promise that resolves with the status of the specified sync(s)
     */
    syncStatus(providerConfigKey: string, syncs: '*' | (string | {
        name: string;
        variant: string;
    })[], connectionId?: string): Promise<SyncStatusResponse>;
    /**
     * Override a sync's default frequency for a specific connection, or revert to the default frequency
     * @param providerConfigKey - The key identifying the provider configuration on Nango
     * @param sync - The name of the sync to update (or an object with name and variant properties)
     * @param connectionId - The ID of the connection for which to update the sync frequency
     * @param frequency - The new frequency to set for the sync, or null to revert to the default frequency
     * @returns A promise that resolves with the response data after updating the sync frequency
     */
    updateSyncConnectionFrequency(providerConfigKey: string, sync: string | {
        name: string;
        variant: string;
    }, connectionId: string, frequency: string | null): Promise<UpdateSyncFrequencyResponse>;
    /**
     * Wait for connection to be created
     * @param integrationKey - The integration key
     * @param userId - The user ID
     * @param options - Optional configuration (signal for cancellation)
     * @returns A promise that resolves when the connection is created
     * @throws {Error} If the wait is aborted via signal or times out
     */
    waitForConnection(integrationKey: string, userId: string, options?: {
        signal?: AbortSignal;
    }): Promise<ApiPublicConnection>;
    /**
     * Creates a new sync variant
     * @param props - The properties for the new variant (provider_config_key, connection_id, name, variant)
     * @returns A promise that resolves with the new sync variant (id, name, variant)
     */
    createSyncVariant(props: PostSyncVariant['Body'] & PostSyncVariant['Params']): Promise<PostSyncVariant['Success']>;
    /**
     *
     * Delete an existing sync variant
     * @param props - The properties of the variant to delete (provider_config_key, connection_id, name, variant)
     * @returns A promise that resolves with void when the sync variant is deleted
     */
    deleteSyncVariant(props: DeleteSyncVariant['Body'] & DeleteSyncVariant['Params']): Promise<DeleteSyncVariant['Success']>;
    /**
     * Retrieve the environment variables as added in the Nango dashboard
     * @returns A promise that resolves with an array of environment variables
     */
    getEnvironmentVariables(): Promise<GetPublicEnvironmentVariables['Success']>;
    /**
     * =======
     * ACTIONS
     *      TRIGGER
     * =======
     */
    private _triggerAction;
    /**
     * Triggers an action for a connection
     * @param providerConfigKey - The key identifying the provider configuration on Nango
     * @param connectionId - The ID of the connection for which the action should be triggered
     * @param actionName - The name of the action to trigger
     * @param input - An optional input data for the action
     * @returns A promise that resolves with an object containing the response data from the triggered action
     */
    triggerAction<In = unknown, Out = object>(providerConfigKey: string, connectionId: string, actionName: string, input?: In): Promise<Out>;
    /**
     * Triggers an action asynchronously for a connection
     * @param providerConfigKey - The key identifying the provider configuration on Nango
     * @param connectionId - The ID of the connection for which the action should be triggered
     * @param actionName - The name of the action to trigger
     * @param input - An optional input data for the action
     * @returns A promise that resolves with the ID of the action and the URL where the result can be retrieved
     */
    triggerActionAsync<In = unknown>(providerConfigKey: string, connectionId: string, actionName: string, input?: In): Promise<{
        id: string;
        statusUrl: string;
    }>;
    /**
     * Retrieves the result of an asynchronous action
     * @param props - The properties of the action to retrieve the result for (id and/or statusUrl)
     * @returns A promise that resolves with the result of the action
     */
    getAsyncActionResult<Out = unknown>(props: Partial<Awaited<ReturnType<Nango['triggerActionAsync']>>>): Promise<Out>;
    /**
     * =======
     * PROXY
     *      GET
     *      POST
     *      PUT
     *      PATCH
     *      DELETE
     * =======
     */
    /**
     * Sends a proxied HTTP request based on the provided configuration
     * @param config - The configuration object for the proxy request
     * @returns A promise that resolves with the response from the proxied request
     */
    proxy<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    /**
     * Sends a GET request using the proxy based on the provided configuration
     * @param config - The configuration object for the GET request
     * @returns A promise that resolves with the response from the GET request
     */
    get<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    /**
     * Sends a POST request using the proxy based on the provided configuration
     * @param config - The configuration object for the POST request
     * @returns A promise that resolves with the response from the POST request
     */
    post<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    /**
     * Sends a PUT request using the proxy based on the provided configuration
     * @param config - The configuration object for the PUT request
     * @returns A promise that resolves with the response from the PUT request
     */
    put<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    /**
     * Sends a PATCH request using the proxy based on the provided configuration
     * @param config - The configuration object for the PATCH request
     * @returns A promise that resolves with the response from the PATCH request
     */
    patch<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    /**
     * Sends a DELETE request using the proxy based on the provided configuration
     * @param config - The configuration object for the DELETE request
     * @returns A promise that resolves with the response from the DELETE request
     */
    delete<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    /**
     *
     * Verify incoming webhooks signature
     *
     * @deprecated **SECURITY WARNING**: This method is vulnerable to length-extension attacks and should NOT be used.
     * Use `verifyIncomingWebhookRequest` instead for secure webhook signature verification.
     *
     * @param signatureInHeader - The value in the header X-Nango-Signature
     * @param jsonPayload - The HTTP body as JSON
     * @returns Whether the signature is valid
     */
    verifyWebhookSignature(signatureInHeader: string, jsonPayload: unknown): boolean;
    private _verifyWebhookSignatureImpl;
    /**
     *
     * Verify incoming webhooks request
     *
     * @param body - The raw HTTP body as a string
     * @param headers - The HTTP headers including X-Nango-Hmac-Sha256
     * @returns Whether the signature is valid
     */
    verifyIncomingWebhookRequest(body: string, headers: Record<string, unknown>): boolean;
    /**
     * Creates a new connect session
     * @param sessionProps - The properties for the new session, including end user information
     * @returns A promise that resolves with the created session token and expiration date
     */
    createConnectSession(sessionProps: PostConnectSessions['Body']): Promise<PostConnectSessions['Success']>;
    /**
     * Creates a new connect session dedicated for reconnecting
     * @param sessionProps - The properties for the new session, including end user information
     * @returns A promise that resolves with the created session token and expiration date
     */
    createReconnectSession(sessionProps: PostPublicConnectSessionsReconnect['Body']): Promise<PostPublicConnectSessionsReconnect['Success']>;
    /**
     * Retrieves details of a specific connection
     * @param options - An object containing the following properties:
     *   - providerConfigKey: The key identifying the provider configuration on Nango
     *   - connectionId: The ID of the connection for which to retrieve connection details
     *   - forceRefresh: Optional. Whether to force a refresh of the access tokens. Defaults to false
     *   - refreshToken: Optional. Whether to send the refresh token as part of the response. Defaults to false
     *   - additionalHeader: Optional. Additional headers to include in the request
     *   - refreshGithubAppJwtToken: Optional. Whether to refresh the JWT token for GitHub App / Github App OAuth connections. Defaults to false
     * @returns A promise that resolves with the response containing connection details
     */
    private getConnectionDetails;
    /**
     * Enriches the headers with the Authorization token and internal flags
     * @param headers - Optional. The headers to enrich
     * @returns The enriched headers
     */
    private enrichHeaders;
}
