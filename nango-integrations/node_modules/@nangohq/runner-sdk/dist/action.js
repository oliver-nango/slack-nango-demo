import { getProvider } from '@nangohq/providers';
import { AbortedSDKError, ActionError, UnknownProviderSDKError } from './errors.js';
import paginateService from './paginate.service.js';
const MEMOIZED_CONNECTION_TTL = 60000;
const MEMOIZED_INTEGRATION_TTL = 10 * 60 * 1000;
export class NangoActionBase {
    attributes = {};
    logger;
    activityLogId;
    syncId;
    nangoConnectionId;
    environmentId;
    environmentName;
    syncJobId;
    abortSignal;
    syncConfig;
    runnerFlags;
    scriptType;
    startTime;
    isCLI;
    connectionId;
    providerConfigKey;
    provider;
    integrationConfig;
    ActionError = ActionError;
    telemetryBag = {
        customLogs: 0,
        proxyCalls: 0,
        durationMs: 0,
        memoryGb: 1
    };
    memoizedConnections = new Map();
    memoizedIntegration = new Map();
    constructor(config) {
        this.connectionId = config.connectionId;
        this.environmentId = config.environmentId;
        this.providerConfigKey = config.providerConfigKey;
        this.runnerFlags = config.runnerFlags;
        this.activityLogId = config.activityLogId;
        this.scriptType = config.scriptType;
        this.isCLI = config.isCLI;
        this.startTime = Date.now();
        if (config.syncId) {
            this.syncId = config.syncId;
        }
        if (config.nangoConnectionId) {
            this.nangoConnectionId = config.nangoConnectionId;
        }
        if (config.syncJobId) {
            this.syncJobId = config.syncJobId;
        }
        if (config.environmentName) {
            this.environmentName = config.environmentName;
        }
        if (config.provider) {
            this.provider = config.provider;
        }
        if (config.attributes) {
            this.attributes = config.attributes;
        }
        if (config.abortSignal) {
            this.abortSignal = config.abortSignal;
        }
        if (config.syncConfig) {
            this.syncConfig = config.syncConfig;
        }
        if (config.integrationConfig) {
            this.integrationConfig = config.integrationConfig;
        }
        this.logger = config.logger || {
            level: 'warn'
        };
    }
    getProxyConfig(config) {
        return {
            method: 'GET',
            ...config,
            providerConfigKey: config.providerConfigKey || this.providerConfigKey,
            headers: {
                ...(config.headers || {}),
                'user-agent': this.nango.userAgent
            }
        };
    }
    throwIfAborted() {
        if (this.abortSignal?.aborted) {
            throw new AbortedSDKError();
        }
    }
    shouldLog(logLevel) {
        const levels = {
            debug: 0,
            info: 1,
            warn: 2,
            error: 3,
            off: 4
        };
        return levels[logLevel] >= levels[this.logger.level];
    }
    async get(config) {
        return this.proxy({
            ...config,
            method: 'GET'
        });
    }
    async post(config) {
        return this.proxy({
            ...config,
            method: 'POST'
        });
    }
    async put(config) {
        return this.proxy({
            ...config,
            method: 'PUT'
        });
    }
    async patch(config) {
        return this.proxy({
            ...config,
            method: 'PATCH'
        });
    }
    async delete(config) {
        return this.proxy({
            ...config,
            method: 'DELETE'
        });
    }
    async getToken() {
        this.throwIfAborted();
        return this.nango.getToken(this.providerConfigKey, this.connectionId);
    }
    /**
     * Get current integration
     */
    async getIntegration(queries) {
        this.throwIfAborted();
        const key = queries?.include?.join(',') || 'default';
        const has = this.memoizedIntegration.get(key);
        if (has && MEMOIZED_INTEGRATION_TTL > Date.now() - has.timestamp) {
            return has.integration;
        }
        const { data: integration } = await this.nango.getIntegration({ uniqueKey: this.providerConfigKey }, queries);
        this.memoizedIntegration.set(key, { integration, timestamp: Date.now() });
        return integration;
    }
    async getConnection(providerConfigKeyOverride, connectionIdOverride, options) {
        this.throwIfAborted();
        const providerConfigKey = providerConfigKeyOverride || this.providerConfigKey;
        const connectionId = connectionIdOverride || this.connectionId;
        const credentialsPair = `${providerConfigKey}${connectionId}`;
        const cached = this.memoizedConnections.get(credentialsPair);
        const shouldRefresh = options?.forceRefresh ||
            options?.refreshToken ||
            options?.refreshGithubAppJwtToken ||
            !cached ||
            Date.now() - cached.timestamp > MEMOIZED_CONNECTION_TTL;
        if (shouldRefresh) {
            const connection = await this.nango.getConnection(providerConfigKey, connectionId, options?.forceRefresh ?? false, options?.refreshToken ?? false, options?.refreshGithubAppJwtToken ?? false);
            this.memoizedConnections.set(credentialsPair, { connection, timestamp: Date.now() });
            return connection;
        }
        return cached.connection;
    }
    async setMetadata(metadata) {
        this.throwIfAborted();
        try {
            return await this.nango.setMetadata(this.providerConfigKey, this.connectionId, metadata);
        }
        finally {
            this.memoizedConnections.delete(`${this.providerConfigKey}${this.connectionId}`);
        }
    }
    async updateMetadata(metadata) {
        this.throwIfAborted();
        try {
            return await this.nango.updateMetadata(this.providerConfigKey, this.connectionId, metadata);
        }
        finally {
            this.memoizedConnections.delete(`${this.providerConfigKey}${this.connectionId}`);
        }
    }
    /**
     * @deprecated please use setMetadata instead.
     */
    async setFieldMapping(fieldMapping) {
        console.warn('setFieldMapping is deprecated. Please use setMetadata instead.');
        return await this.setMetadata(fieldMapping);
    }
    async getMetadata() {
        this.throwIfAborted();
        return (await this.getConnection(this.providerConfigKey, this.connectionId)).metadata;
    }
    async getWebhookURL() {
        this.throwIfAborted();
        const integration = await this.getIntegration({ include: ['webhook'] });
        return integration.webhook_url;
    }
    /**
     * @deprecated please use getMetadata instead.
     */
    async getFieldMapping() {
        console.warn('getFieldMapping is deprecated. Please use getMetadata instead.');
        const metadata = (await this.getMetadata());
        return metadata['fieldMapping'] || {};
    }
    /**
     * Set logger
     * @desc Set the default logger level
     * @param logger { level: 'debug' | 'info' | 'warn' | 'error' | 'off' }
     * @example
     * ```ts
     * nango.setLogger({ level: 'warn' })
     * ```
     */
    setLogger(logger) {
        // If the current logger is off, we don't allow changing it
        if (this.logger.level === 'off') {
            return;
        }
        this.logger = logger;
    }
    async getEnvironmentVariables() {
        return await this.nango.getEnvironmentVariables();
    }
    getFlowAttributes() {
        if (!this.syncJobId) {
            throw new Error('There is no current sync to get attributes from');
        }
        return this.attributes;
    }
    async *paginate(config) {
        const provider = getProvider(this.provider);
        if (!provider) {
            throw new UnknownProviderSDKError({ provider: this.provider });
        }
        const templatePaginationConfig = provider.proxy?.paginate;
        if (!templatePaginationConfig && (!config.paginate || !config.paginate.type)) {
            throw Error('There was no pagination configuration for this integration or configuration passed in.');
        }
        const paginationConfig = {
            ...(templatePaginationConfig || {}),
            ...(config.paginate || {})
        };
        paginateService.validateConfiguration(paginationConfig);
        config.method = config.method || 'GET';
        const configMethod = config.method.toLocaleLowerCase();
        const passPaginationParamsInBody = config.paginate?.in_body ?? ['post', 'put', 'patch'].includes(configMethod);
        const updatedBodyOrParams = (passPaginationParamsInBody ? config.data : config.params) ?? {};
        const limitParameterName = paginationConfig.limit_name_in_request;
        if (paginationConfig['limit']) {
            updatedBodyOrParams[limitParameterName] = paginationConfig['limit'];
        }
        const proxyConfig = this.getProxyConfig(config);
        switch (paginationConfig.type) {
            case 'cursor':
                return yield* paginateService.cursor(proxyConfig, paginationConfig, updatedBodyOrParams, passPaginationParamsInBody, this.proxy.bind(this));
            case 'link':
                return yield* paginateService.link(proxyConfig, paginationConfig, updatedBodyOrParams, passPaginationParamsInBody, this.proxy.bind(this));
            case 'offset':
                return yield* paginateService.offset(proxyConfig, paginationConfig, updatedBodyOrParams, passPaginationParamsInBody, this.proxy.bind(this));
            default:
                throw Error(`'${paginationConfig['type']}' pagination is not supported.}`);
        }
    }
    async triggerAction(providerConfigKey, connectionId, actionName, input) {
        return await this.nango.triggerAction(providerConfigKey, connectionId, actionName, input);
    }
    async zodValidateInput({ zodSchema, input }) {
        const parsedInput = zodSchema.safeParse(input);
        if (!parsedInput.success) {
            for (const error of parsedInput.error.issues) {
                await this.log(`Invalid input provided: ${error.message} at path ${error.path.join('.')}`, { level: 'error' });
            }
            throw new this.ActionError({
                message: 'Invalid input provided'
            });
        }
        return parsedInput;
    }
    /**
     * Uncontrolled fetch is a regular fetch without retry or credentials injection.
     * Only use that method when you want to access resources that are unrelated to the current connection/provider.
     */
    async uncontrolledFetch(options) {
        const props = {
            headers: new Headers(options.headers),
            method: options.method || 'GET'
            // TODO: use agent
        };
        if (options.body) {
            props.body = options.body;
        }
        return await fetch(options.url, props);
    }
}
//# sourceMappingURL=action.js.map