import { ActionError } from './errors.js';
import type { ZodMetadata } from './types.js';
import type { Nango } from '@nangohq/node';
import type { ApiKeyCredentials, ApiPublicConnectionFull, AppCredentials, AppStoreCredentials, BasicApiCredentials, BillCredentials, CustomCredentials, EnvironmentVariable, GetPublicConnection, GetPublicIntegration, HTTP_METHOD, JwtCredentials, MaybePromise, NangoProps, OAuth1Token, OAuth2ClientCredentials, PostPublicTrigger, SdkLogger, SetMetadata, SignatureCredentials, TbaCredentials, TelemetryBag, TwoStepCredentials, UnauthCredentials, UpdateMetadata, UserLogParameters, UserProvidedProxyConfiguration } from '@nangohq/types';
import type { AxiosResponse } from 'axios';
import type * as z from 'zod';
export type ProxyConfiguration = Omit<UserProvidedProxyConfiguration, 'files' | 'providerConfigKey' | 'connectionId'> & {
    providerConfigKey?: string;
    connectionId?: string;
};
export declare abstract class NangoActionBase<TMetadata extends ZodMetadata = never, TMetadataInferred = TMetadata extends never ? never : z.infer<Exclude<TMetadata, undefined>>> {
    abstract nango: Nango;
    private attributes;
    logger: SdkLogger;
    activityLogId: string;
    syncId?: string;
    nangoConnectionId?: number;
    environmentId: number;
    environmentName?: string;
    syncJobId?: number;
    abortSignal?: NangoProps['abortSignal'];
    syncConfig?: NangoProps['syncConfig'];
    runnerFlags: NangoProps['runnerFlags'];
    scriptType: NangoProps['scriptType'];
    startTime: number;
    isCLI: NangoProps['isCLI'];
    connectionId: string;
    providerConfigKey: string;
    provider?: string;
    integrationConfig?: NangoProps['integrationConfig'];
    ActionError: typeof ActionError;
    telemetryBag: TelemetryBag;
    protected memoizedConnections: Map<string, {
        connection: ApiPublicConnectionFull;
        timestamp: number;
    }>;
    protected memoizedIntegration: Map<string, {
        integration: GetPublicIntegration["Success"]["data"];
        timestamp: number;
    }>;
    constructor(config: NangoProps);
    protected getProxyConfig(config: ProxyConfiguration): UserProvidedProxyConfiguration;
    protected throwIfAborted(): void;
    protected shouldLog(logLevel: SdkLogger['level']): boolean;
    abstract proxy<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    get<T = any>(config: Omit<ProxyConfiguration, 'method'>): Promise<AxiosResponse<T>>;
    post<T = any>(config: Omit<ProxyConfiguration, 'method'>): Promise<AxiosResponse<T>>;
    put<T = any>(config: Omit<ProxyConfiguration, 'method'>): Promise<AxiosResponse<T>>;
    patch<T = any>(config: Omit<ProxyConfiguration, 'method'>): Promise<AxiosResponse<T>>;
    delete<T = any>(config: Omit<ProxyConfiguration, 'method'>): Promise<AxiosResponse<T>>;
    getToken(): Promise<string | OAuth1Token | OAuth2ClientCredentials | BasicApiCredentials | ApiKeyCredentials | AppCredentials | AppStoreCredentials | UnauthCredentials | CustomCredentials | TbaCredentials | JwtCredentials | BillCredentials | TwoStepCredentials | SignatureCredentials>;
    /**
     * Get current integration
     */
    getIntegration(queries?: GetPublicIntegration['Querystring']): Promise<GetPublicIntegration['Success']['data']>;
    getConnection(providerConfigKeyOverride?: string, connectionIdOverride?: string, options?: {
        refreshToken?: boolean;
        refreshGithubAppJwtToken?: boolean;
        forceRefresh?: boolean;
    }): Promise<GetPublicConnection['Success']>;
    setMetadata(metadata: TMetadataInferred): Promise<AxiosResponse<SetMetadata['Success']>>;
    updateMetadata(metadata: Partial<TMetadataInferred>): Promise<AxiosResponse<UpdateMetadata['Success']>>;
    /**
     * @deprecated please use setMetadata instead.
     */
    setFieldMapping(fieldMapping: Record<string, string>): Promise<AxiosResponse<object>>;
    getMetadata<T = TMetadataInferred>(): Promise<T>;
    getWebhookURL(): Promise<string | null | undefined>;
    /**
     * @deprecated please use getMetadata instead.
     */
    getFieldMapping(): Promise<Record<string, string>>;
    /**
     * Log
     * @desc Log a message to the activity log which shows up in the Nango Dashboard
     * note that the last argument can be an object with a level property to specify the log level
     * @example
     * ```ts
     * await nango.log('This is a log message', { level: 'error' })
     * ```
     */
    abstract log(message: any, options?: UserLogParameters | {
        [key: string]: any;
        level?: never;
    }): MaybePromise<void>;
    abstract log(message: string, ...args: [any, UserLogParameters]): MaybePromise<void>;
    abstract log(...args: [...any]): MaybePromise<void>;
    /**
     * Set logger
     * @desc Set the default logger level
     * @param logger { level: 'debug' | 'info' | 'warn' | 'error' | 'off' }
     * @example
     * ```ts
     * nango.setLogger({ level: 'warn' })
     * ```
     */
    setLogger(logger: SdkLogger): void;
    getEnvironmentVariables(): Promise<EnvironmentVariable[] | null>;
    getFlowAttributes<A = object>(): A | null;
    paginate<T = any>(config: ProxyConfiguration): AsyncGenerator<T[], undefined, void>;
    triggerAction<In = unknown, Out = object>(providerConfigKey: string, connectionId: string, actionName: string, input?: In): Promise<Out>;
    zodValidateInput<T = any, Z = any>({ zodSchema, input }: {
        zodSchema: z.ZodType<Z>;
        input: T;
    }): Promise<z.ZodSafeParseSuccess<Z>>;
    abstract triggerSync(providerConfigKey: string, connectionId: string, sync: string | {
        name: string;
        variant: string;
    }, syncMode?: PostPublicTrigger['Body']['sync_mode'] | boolean): Promise<void | string>;
    abstract startSync(providerConfigKey: string, syncs: (string | {
        name: string;
        variant: string;
    })[], connectionId?: string): Promise<void>;
    /**
     * Uncontrolled fetch is a regular fetch without retry or credentials injection.
     * Only use that method when you want to access resources that are unrelated to the current connection/provider.
     */
    uncontrolledFetch(options: {
        url: URL;
        method?: HTTP_METHOD;
        headers?: Record<string, string> | undefined;
        body?: string | null;
    }): Promise<Response>;
    /**
     * Try to acquire a lock for a given key.
     * The lock is acquired if the key does not exist or if it exists but is expired.
     * The lock is valid for the entire execution of the script and will be released automatically when the script ends (or when releaseLock is called).
     */
    abstract tryAcquireLock({ key, ttlMs }: {
        key: string;
        ttlMs: number;
    }): Promise<boolean>;
    /**
     * Release the lock for a given key.
     */
    abstract releaseLock({ key }: {
        key: string;
    }): Promise<boolean>;
    /**
     * Release all locks acquired during the execution of a script.
     */
    abstract releaseAllLocks(): Promise<void>;
}
