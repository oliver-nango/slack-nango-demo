import { NangoActionBase } from './action.js';
import type { ValidateDataError } from './dataValidation.js';
import type { RawModel, ZodMetadata, ZodModel } from './types.js';
import type { MaybePromise, NangoProps } from '@nangohq/types';
import type * as z from 'zod';
export declare const BASE_VARIANT = "base";
export declare abstract class NangoSyncBase<TModels extends Record<string, ZodModel> = never, TMetadata extends ZodMetadata = never, TModelName extends keyof TModels = keyof TModels> extends NangoActionBase<TMetadata> {
    variant: string;
    lastSyncDate?: Date;
    track_deletes: boolean;
    constructor(config: NangoProps);
    modelFullName(model: string): string;
    /**
     * @deprecated please use batchSave
     */
    batchSend<TModel extends RawModel = z.infer<TModels[TModelName]>>(results: TModel[], model: TModelName): Promise<boolean | null>;
    abstract batchSave<TModel extends RawModel = z.infer<TModels[TModelName]>>(results: TModel[], model: TModelName): MaybePromise<boolean>;
    abstract batchDelete<TModel extends RawModel = z.infer<TModels[TModelName]>>(results: (Pick<TModel, 'id'> & Partial<TModel>)[], model: TModelName): MaybePromise<boolean>;
    abstract batchUpdate<TModel extends RawModel = z.infer<TModels[TModelName]>>(results: (Pick<TModel, 'id'> & Partial<TModel>)[], model: TModelName): MaybePromise<boolean>;
    abstract getRecordsByIds<TKey = string | number, TModel extends RawModel = z.infer<TModels[TModelName]>>(ids: TKey[], model: TModelName): MaybePromise<Map<TKey, TModel>>;
    abstract deleteRecordsFromPreviousExecutions(model: TModelName): MaybePromise<{
        deletedKeys: string[];
    }>;
    abstract setMergingStrategy(merging: {
        strategy: 'ignore_if_modified_after' | 'override';
    }, model: TModelName): Promise<void>;
    protected validateRecords(model: string, records: unknown[]): {
        data: any;
        validation: ValidateDataError[];
    }[];
    protected removeMetadata<T extends object>(results: T[]): T[];
}
