import get from 'lodash-es/get.js';
import set from 'lodash-es/set.js';
import parseLinksHeader from 'parse-link-header';
function isValidURL(str) {
    try {
        new URL(str); // TODO: replace with canParse after we drop node v18
        return true;
    }
    catch {
        return false;
    }
}
class PaginationService {
    validateConfiguration(paginationConfig) {
        if (!paginationConfig.type) {
            throw new Error('Pagination type is required');
        }
        const { type } = paginationConfig;
        if (paginationConfig.type === 'cursor') {
            const cursorPagination = paginationConfig;
            if (!cursorPagination.cursor_name_in_request) {
                throw new Error('Param cursor_name_in_request is required for cursor pagination');
            }
            if (!cursorPagination.cursor_path_in_response) {
                throw new Error('Param cursor_path_in_response is required for cursor pagination');
            }
            if (paginationConfig.limit && !paginationConfig.limit_name_in_request) {
                throw new Error('Param limit_name_in_request is required for cursor pagination when limit is set');
            }
        }
        else if (type === 'link') {
            const linkPagination = paginationConfig;
            if (!linkPagination.link_rel_in_response_header && !linkPagination.link_path_in_response_body) {
                throw new Error('Either param link_rel_in_response_header or link_path_in_response_body is required for link pagination');
            }
        }
        else if (type === 'offset') {
            const offsetPagination = paginationConfig;
            if (!offsetPagination.offset_name_in_request) {
                throw new Error('Param offset_name_in_request is required for offset pagination');
            }
        }
        else {
            throw new Error(`Pagination type ${type} is not supported. Only cursor, link and offset pagination types are supported.`);
        }
    }
    async *cursor(config, paginationConfig, updatedBodyOrParams, passPaginationParamsInBody, proxy) {
        const cursorPagination = paginationConfig;
        let nextCursor;
        do {
            if (typeof nextCursor !== 'undefined') {
                updatedBodyOrParams[cursorPagination.cursor_name_in_request] = nextCursor;
            }
            this.updateConfigBodyOrParams(passPaginationParamsInBody, config, updatedBodyOrParams);
            const response = await proxy(config);
            const responseData = cursorPagination.response_path ? get(response.data, cursorPagination.response_path) : response.data;
            if (!responseData || !responseData.length) {
                return;
            }
            yield responseData;
            nextCursor = get(response.data, cursorPagination.cursor_path_in_response);
            if (typeof nextCursor === 'string') {
                nextCursor = nextCursor.trim();
                if (!nextCursor) {
                    nextCursor = undefined;
                }
            }
            else if (typeof nextCursor !== 'number') {
                nextCursor = undefined;
            }
            if (paginationConfig.on_page) {
                await paginationConfig.on_page({
                    nextPageParam: nextCursor,
                    response
                });
            }
        } while (typeof nextCursor !== 'undefined');
    }
    async *link(config, paginationConfig, updatedBodyOrParams, passPaginationParamsInBody, proxy) {
        const linkPagination = paginationConfig;
        this.updateConfigBodyOrParams(passPaginationParamsInBody, config, updatedBodyOrParams);
        let previousPageLink;
        while (true) {
            const response = await proxy(config);
            const responseData = paginationConfig.response_path ? get(response.data, paginationConfig.response_path) : response.data;
            yield responseData;
            const nextPageLink = this.getNextPageLinkFromBodyOrHeaders(linkPagination, response, paginationConfig);
            if (paginationConfig.on_page) {
                await paginationConfig.on_page({ nextPageParam: nextPageLink, response });
            }
            if (!nextPageLink || nextPageLink === previousPageLink) {
                return;
            }
            previousPageLink = nextPageLink;
            if (!isValidURL(nextPageLink)) {
                // some providers only send path+query params in the link so we can immediately assign those to the endpoint
                config.endpoint = nextPageLink;
            }
            else {
                const url = new URL(nextPageLink);
                // since this is a fully formed URL then we can reliably use this
                // also since this might contain the base URL we need to override it
                config.baseUrlOverride = url.origin;
                // ensure that the base URL doesn't contain the path
                config.endpoint = url.pathname + url.search;
            }
            delete config.params;
        }
    }
    async *offset(config, paginationConfig, updatedBodyOrParams, passPaginationParamsInBody, proxy) {
        const offsetPagination = paginationConfig;
        const offsetParameterName = offsetPagination.offset_name_in_request;
        const offsetCalculationMethod = offsetPagination.offset_calculation_method || 'by-response-size';
        let offset = offsetPagination.offset_start_value || 0;
        while (true) {
            updatedBodyOrParams[offsetParameterName] = passPaginationParamsInBody ? offset : String(offset);
            this.updateConfigBodyOrParams(passPaginationParamsInBody, config, updatedBodyOrParams);
            const response = await proxy(config);
            const responseData = paginationConfig.response_path ? get(response.data, paginationConfig.response_path) : response.data;
            if (!responseData || !responseData.length) {
                return;
            }
            yield responseData;
            if (paginationConfig['limit'] && responseData.length < Number(paginationConfig['limit'])) {
                return;
            }
            if (paginationConfig.on_page) {
                await paginationConfig.on_page({
                    nextPageParam: offset,
                    response
                });
            }
            if (responseData.length < 1) {
                // Last page was empty so no need to fetch further
                return;
            }
            if (offsetCalculationMethod === 'per-page') {
                offset++;
            }
            else {
                offset += responseData.length;
            }
        }
    }
    /*
     * Update the config object with the updated body or params based on the pagination type
     * @desc if a pagination type requires the pagination params to be passed in the body,
     * then the updatedBodyOrParams will be passed in the body of the config object,
     * with handling for . notation in the keys
     */
    updateConfigBodyOrParams(passPaginationParamsInBody, config, updatedBodyOrParams) {
        if (passPaginationParamsInBody) {
            const expandedParams = Object.keys(updatedBodyOrParams).reduce((acc, key) => {
                set(acc, key, updatedBodyOrParams[key]);
                return acc;
            }, {});
            config.data = expandedParams;
        }
        else {
            config.params = updatedBodyOrParams;
        }
    }
    getNextPageLinkFromBodyOrHeaders(linkPagination, response, paginationConfig) {
        if (!linkPagination.link_rel_in_response_header && !linkPagination.link_path_in_response_body) {
            throw Error(`Either 'link_rel_in_response_header' or 'link_path_in_response_body' should be specified for '${paginationConfig.type}' pagination`);
        }
        let nextPageLink;
        if (linkPagination.link_rel_in_response_header) {
            const linkHeader = parseLinksHeader(response.headers['link']);
            nextPageLink = linkHeader?.[linkPagination.link_rel_in_response_header]?.url;
        }
        if (!nextPageLink && linkPagination.link_path_in_response_body) {
            nextPageLink = get(response.data, linkPagination.link_path_in_response_body);
        }
        return nextPageLink;
    }
}
export default new PaginationService();
//# sourceMappingURL=paginate.service.js.map