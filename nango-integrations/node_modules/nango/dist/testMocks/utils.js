import * as crypto from 'crypto';
import { promises as fs } from 'fs';
import * as path from 'path';
import { vi } from 'vitest';
import { getProvider } from '@nangohq/providers';
import { ActionError, PaginationService } from '@nangohq/runner-sdk';
class NangoActionMock {
    dirname;
    name;
    Model;
    paginationService;
    nango = { secretKey: 'secret-key' };
    activityLogId = 'test-activity-log-id';
    syncId;
    nangoConnectionId;
    environmentId = 1;
    environmentName;
    syncJobId;
    abortSignal;
    syncConfig;
    runnerFlags = {};
    scriptType = 'action';
    startTime = Date.now();
    isCLI = false;
    connectionId;
    providerConfigKey;
    provider;
    ActionError = ActionError;
    telemetryBag = {
        customLogs: 0,
        proxyCalls: 0,
        durationMs: 0,
        memoryGb: 1
    };
    logger = { level: 'debug' };
    setLogger;
    log;
    getConnection;
    getMetadata;
    updateMetadata;
    paginate;
    get;
    post;
    patch;
    put;
    delete;
    proxy;
    getWebhookURL;
    getToken;
    getIntegration;
    setMetadata;
    setFieldMapping;
    getFieldMapping;
    getEnvironmentVariables;
    getFlowAttributes;
    triggerAction;
    triggerSync;
    zodValidateInput;
    startSync;
    uncontrolledFetch;
    tryAcquireLock;
    releaseLock;
    releaseAllLocks;
    constructor({ dirname, name, Model }) {
        this.dirname = dirname;
        this.nango = {
            secretKey: 'secret-key'
        };
        this.providerConfigKey = dirname;
        this.connectionId = 'test-connection-id';
        this.name = name;
        this.Model = Model;
        this.paginationService = PaginationService;
        this.setLogger = vi.fn();
        this.log = vi.fn();
        this.getConnection = vi.fn(this.getConnectionData.bind(this));
        this.getMetadata = vi.fn(this.getMetadataData.bind(this));
        this.paginate = vi.fn(this.getProxyPaginateData.bind(this));
        this.get = vi.fn(this.proxyGetData.bind(this));
        this.post = vi.fn(this.proxyPostData.bind(this));
        this.patch = vi.fn(this.proxyPatchData.bind(this));
        this.put = vi.fn(this.proxyPutData.bind(this));
        this.delete = vi.fn(this.proxyDeleteData.bind(this));
        this.proxy = vi.fn(this.proxyData.bind(this));
        this.getWebhookURL = vi.fn(() => 'https://example.com/webhook');
        this.updateMetadata = vi.fn();
        this.getToken = vi.fn();
        this.getIntegration = vi.fn();
        this.setMetadata = vi.fn();
        this.setFieldMapping = vi.fn();
        this.getFieldMapping = vi.fn();
        this.getEnvironmentVariables = vi.fn();
        this.getFlowAttributes = vi.fn();
        this.triggerAction = vi.fn();
        this.triggerSync = vi.fn();
        this.zodValidateInput = vi.fn();
        this.startSync = vi.fn();
        this.uncontrolledFetch = vi.fn();
        this.tryAcquireLock = vi.fn();
        this.releaseLock = vi.fn();
        this.releaseAllLocks = vi.fn();
    }
    async getMockFile(fileName, throwOnMissing, identity) {
        const filePath = path.resolve(this.dirname, `mocks/${fileName}.json`);
        try {
            const fileContent = await fs.readFile(filePath, 'utf-8');
            const data = JSON.parse(fileContent);
            return data;
        }
        catch (err) {
            if (identity && identity.requestIdentity && fileName.includes(identity.requestIdentityHash)) {
                const normalizedHash = computeNormalizedHash(identity.requestIdentity);
                if (normalizedHash !== identity.requestIdentityHash) {
                    const fallbackFileName = fileName.replace(identity.requestIdentityHash, normalizedHash);
                    const fallbackFilePath = path.resolve(this.dirname, `mocks/${fallbackFileName}.json`);
                    try {
                        const fileContent = await fs.readFile(fallbackFilePath, 'utf-8');
                        const data = JSON.parse(fileContent);
                        return data;
                        // eslint-disable-next-line no-empty
                    }
                    catch { }
                }
            }
            if (throwOnMissing) {
                throw new Error(`Failed to load mock data from ${filePath}: ${err.message} ${identity ? JSON.stringify(identity, null, 2) : ''}`);
            }
        }
    }
    async hashDirExists(hashDir) {
        const filePath = path.resolve(this.dirname, `mocks/${hashDir}/`);
        try {
            await fs.stat(filePath);
            return true;
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
        }
        catch (err) {
            return false;
        }
    }
    async getCachedResponse(identity) {
        const dir = `nango/${identity.method}/proxy/${identity.endpoint}/${this.name}/`;
        const hashBasedPath = `${dir}/${identity.requestIdentityHash}`;
        if (await this.hashDirExists(dir)) {
            const data = await this.getMockFile(hashBasedPath, true, identity);
            return data;
        }
        else {
            return {
                response: await this.getMockFile(`nango/${identity.method}/proxy/${identity.endpoint}/${this.name}`, true, identity)
            };
        }
    }
    async getBatchSaveData(modelName) {
        const data = await this.getMockFile(`${this.name}/${modelName}/batchSave`, true);
        return data;
    }
    async getBatchDeleteData(modelName) {
        const data = await this.getMockFile(`${this.name}/${modelName}/batchDelete`, true);
        return data;
    }
    async getInput() {
        const data = await this.getMockFile(`${this.name}/input`, false);
        return data;
    }
    async getOutput() {
        const data = await this.getMockFile(`${this.name}/output`, true);
        return data;
    }
    async getConnectionData() {
        const data = await this.getMockFile(`nango/getConnection`, true);
        return data;
    }
    async getMetadataData() {
        const data = await this.getMockFile('nango/getMetadata', true);
        return data;
    }
    async *getProxyPaginateData(args) {
        const providerConfig = getProvider(this.providerConfigKey);
        if (!providerConfig) {
            throw new Error(`Provider config not found for ${this.providerConfigKey}`);
        }
        args.method = args.method || 'get';
        args.paginate = {
            ...providerConfig.proxy?.paginate,
            ...args.paginate
        };
        const paginateInBody = ['post', 'put', 'patch'].includes(args.method.toLowerCase());
        const updatedBodyOrParams = paginateInBody ? args.data || {} : args.params || {};
        if (args.paginate['limit']) {
            const limitParameterName = args.paginate.limit_name_in_request;
            if (typeof updatedBodyOrParams === 'object') {
                updatedBodyOrParams[limitParameterName] = args.paginate['limit'];
            }
        }
        const proxyFunction = async (config) => {
            const response = await this.proxyData(config);
            return {
                data: response.data,
                status: response.status,
                statusText: 'OK',
                headers: response.headers,
                config: {}
            };
        };
        if (args.paginate.type === 'cursor') {
            yield* this.paginationService.cursor(args, args.paginate, updatedBodyOrParams, paginateInBody, proxyFunction);
        }
        else if (args.paginate.type === 'link') {
            yield* this.paginationService.link(args, args.paginate, updatedBodyOrParams, paginateInBody, proxyFunction);
        }
        else if (args.paginate.type === 'offset') {
            yield* this.paginationService.offset(args, args.paginate, updatedBodyOrParams, paginateInBody, proxyFunction);
        }
        else {
            throw new Error(`Invalid pagination type: ${args.paginate?.type}`);
        }
    }
    async proxyGetData(args) {
        return this.proxyData({ ...args, method: 'get' });
    }
    async proxyPostData(args) {
        return this.proxyData({ ...args, method: 'post' });
    }
    async proxyPatchData(args) {
        return this.proxyData({ ...args, method: 'patch' });
    }
    async proxyPutData(args) {
        return this.proxyData({ ...args, method: 'put' });
    }
    async proxyDeleteData(args) {
        return this.proxyData({ ...args, method: 'delete' });
    }
    async proxyData(args) {
        const identity = computeConfigIdentity(args);
        const cached = await this.getCachedResponse(identity);
        return {
            data: cached.response,
            headers: cached.headers,
            status: cached.status
        };
    }
}
class NangoSyncMock extends NangoActionMock {
    variant = 'base';
    track_deletes = false;
    batchSave;
    batchDelete;
    batchUpdate;
    getRecordsByIds;
    deleteRecordsFromPreviousExecutions;
    setMergingStrategy;
    batchSend;
    modelFullName(model) {
        if (this.variant === 'base') {
            return model;
        }
        return `${model}::${this.variant}`;
    }
    constructor({ dirname, name, Model }) {
        super({ dirname, name, Model });
        this.batchSave = vi.fn();
        this.batchDelete = vi.fn();
        this.batchUpdate = vi.fn();
        this.getRecordsByIds = vi.fn();
        this.deleteRecordsFromPreviousExecutions = vi.fn();
        this.setMergingStrategy = vi.fn();
        this.batchSend = vi.fn();
    }
}
const FILTER_HEADERS = ['authorization', 'user-agent', 'nango-proxy-user-agent', 'accept-encoding', 'retries', 'host', 'connection-id', 'provider-config-key'];
function computeConfigIdentity(config) {
    const method = config.method?.toLowerCase() || 'get';
    const params = sortEntries(Object.entries(config.params || {}));
    const endpoint = config.endpoint.startsWith('/') ? config.endpoint.slice(1) : config.endpoint;
    const dataIdentity = computeDataIdentity(config);
    const filteredHeaders = Object.entries(config.headers || {}).filter(([key]) => !FILTER_HEADERS.includes(key.toLowerCase()));
    sortEntries(filteredHeaders);
    const headers = filteredHeaders;
    const requestIdentity = {
        method,
        endpoint,
        params,
        headers,
        data: dataIdentity
    };
    const requestIdentityHash = crypto.createHash('sha1').update(JSON.stringify(requestIdentity)).digest('hex');
    return {
        method,
        endpoint,
        requestIdentityHash,
        requestIdentity
    };
}
function sortEntries(entries) {
    return entries.sort((a, b) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0));
}
function computeNormalizedHash(requestIdentity) {
    const normalized = {
        ...requestIdentity,
        params: requestIdentity.params.map(([k, v]) => [k, String(v)])
    };
    return crypto.createHash('sha1').update(JSON.stringify(normalized)).digest('hex');
}
function computeDataIdentity(config) {
    const data = config.data;
    if (!data) {
        return undefined;
    }
    let dataString = '';
    if (typeof data === 'string') {
        dataString = data;
    }
    else if (Buffer.isBuffer(data)) {
        dataString = data.toString('base64');
    }
    else {
        try {
            dataString = JSON.stringify(data);
        }
        catch (err) {
            if (err instanceof Error) {
                throw new Error(`Unable to compute request identity: ${err.message}`);
            }
            else {
                throw new Error('Unable to compute request identity');
            }
        }
    }
    if (dataString.length > 1000) {
        return 'sha1:' + crypto.createHash('sha1').update(dataString).digest('hex');
    }
    else {
        return dataString;
    }
}
export { NangoActionMock, NangoSyncMock };
//# sourceMappingURL=utils.js.map