// When adding support for new Zod types,
// check if rendering it is well supported in webapp functions input/output rendering and add support accordingly
export function zodToNangoModelField(name, schema) {
    const optional = schema.safeParse(undefined).success;
    if (isZodObject(schema)) {
        const values = [];
        for (const [key, value] of Object.entries(schema.shape)) {
            values.push(zodToNangoModelField(key, value));
        }
        return { name, value: values, optional, description: schema.description };
    }
    else if (isZodString(schema)) {
        return { name, value: 'string', tsType: true, optional, description: schema.description };
    }
    else if (isZodLiteral(schema)) {
        if (schema.def.values.length > 1) {
            const values = [];
            for (const [key, value] of Object.entries(schema.def.values)) {
                values.push({ name: key.toString(), value: value, description: schema.description });
            }
            return { name, value: values, optional, union: true, description: schema.description };
        }
        return { name, value: schema.def.values[0], optional, description: schema.description };
    }
    else if (isZodNumber(schema)) {
        return { name, value: 'number', tsType: true, optional, description: schema.description };
    }
    else if (isZodBoolean(schema)) {
        return { name, value: 'boolean', tsType: true, optional, description: schema.description };
    }
    else if (isZodNull(schema)) {
        return { name, value: null, tsType: true, optional, description: schema.description };
    }
    else if (isZodNullable(schema)) {
        return { ...zodToNangoModelField(name, schema.def.innerType), optional, description: schema.description };
    }
    else if (isZodEnum(schema)) {
        const values = [];
        let i = 0;
        for (const value of Object.values(schema.def.entries)) {
            values.push({ name: i.toString(), value: value, description: schema.description });
            i++;
        }
        return { name, value: values, optional, union: true, description: schema.description };
    }
    else if (isZodAny(schema)) {
        return { name, value: 'any', tsType: true, optional, description: schema.description };
    }
    else if (isZodDate(schema)) {
        return { name, value: 'Date', tsType: true, optional, description: schema.description };
    }
    else if (isZodRecord(schema)) {
        return { name, value: [{ ...zodToNangoModelField('__string', schema.def.valueType), dynamic: true }], optional, description: schema.description };
    }
    else if (isZodArray(schema)) {
        // console.log('array', schema.def);
        const value = zodToNangoModelField('0', schema.def.element);
        if (isZodObject(schema.def.element)) {
            return { name, value: [value], array: true, optional, description: schema.description };
        }
        return { name, value: value.value, tsType: true, array: true, optional, description: schema.description };
    }
    else if (isZodUnion(schema) || isZodDiscriminatedUnion(schema)) {
        const values = [];
        for (const [key, value] of Object.entries(schema._zod.def.options)) {
            values.push(zodToNangoModelField(key, value));
        }
        return { name, value: values, tsType: true, union: true, optional, description: schema.description };
    }
    else if (isZodNever(schema)) {
        return { name, value: 'never', tsType: true, optional, description: schema.description };
    }
    else if (isZodVoid(schema)) {
        return { name, value: 'void', tsType: true, description: schema.description }; // No optional on purpose because void | undefined is not valid
    }
    else if (isZodOptional(schema)) {
        return { ...zodToNangoModelField(name, schema.def.innerType), optional, description: schema.description };
    }
    else if (isZodUndefined(schema)) {
        throw new Error('z.undefined() is not supported, please use z.null() or z.optional() instead');
    }
    else if (isZodUnknown(schema)) {
        return { name, value: 'unknown', tsType: true, optional, description: schema.description };
    }
    else if (isZodBigInt(schema)) {
        return { name, value: 'bigint', tsType: true, optional, description: schema.description };
    }
    else if (isZodEmail(schema)) {
        // Not supported yet by "ts-json-schema-generator" (2.4.0)
        // return { name, value: 'email', tsType: true, optional };
        throw new Error(`z.email() is not supported, please use z.string() instead`);
    }
    else if (isZodUrl(schema)) {
        // Not supported yet by "ts-json-schema-generator" (2.4.0)
        // return { name, value: 'url', tsType: true, optional };
        throw new Error(`z.url() is not supported, please use z.string() instead`);
    }
    else if (isZodTuple(schema)) {
        // const values: NangoModelField['value'] = [];
        // for (const [key, value] of Object.entries(schema._zod.def.items)) {
        //     values.push(zodToNangoModelField(key, value));
        // }
        // return { name, value: values, tsType: true, array: true, optional };
        throw new Error(`z.tuple() is not supported, please use z.array() instead`);
    }
    else {
        throw new Error(`field "${name}" contains an unsupported Zod type, please change or reach out to Nango support, ${JSON.stringify(schema)}`);
    }
}
// We are using type guards because instanceof does not work
// the files are compiled and the zod version loaded by the scripts is the not the same
// (at least that's my interpretation, as it works in unit test)
function isZodObject(schema) {
    return schema.constructor.name === 'ZodObject';
}
function isZodString(schema) {
    return schema.constructor.name === 'ZodString';
}
function isZodLiteral(schema) {
    return schema.constructor.name === 'ZodLiteral';
}
function isZodNumber(schema) {
    return schema.constructor.name === 'ZodNumber';
}
function isZodBoolean(schema) {
    return schema.constructor.name === 'ZodBoolean';
}
function isZodNull(schema) {
    return schema.constructor.name === 'ZodNull';
}
function isZodEnum(schema) {
    return schema.constructor.name === 'ZodEnum';
}
function isZodArray(schema) {
    return schema.constructor.name === 'ZodArray';
}
function isZodUnion(schema) {
    return schema.constructor.name === 'ZodUnion';
}
function isZodAny(schema) {
    return schema.constructor.name === 'ZodAny';
}
function isZodRecord(schema) {
    return schema.constructor.name === 'ZodRecord';
}
function isZodDate(schema) {
    return schema.constructor.name === 'ZodDate';
}
function isZodNever(schema) {
    return schema.constructor.name === 'ZodNever';
}
function isZodVoid(schema) {
    return schema.constructor.name === 'ZodVoid';
}
function isZodOptional(schema) {
    return schema.constructor.name === 'ZodOptional';
}
function isZodNullable(schema) {
    return schema.constructor.name === 'ZodNullable';
}
function isZodUndefined(schema) {
    return schema.constructor.name === 'ZodUndefined';
}
function isZodUnknown(schema) {
    return schema.constructor.name === 'ZodUnknown';
}
function isZodDiscriminatedUnion(schema) {
    return schema.constructor.name === 'ZodDiscriminatedUnion';
}
function isZodBigInt(schema) {
    return schema.constructor.name === 'ZodBigInt';
}
function isZodEmail(schema) {
    return schema.constructor.name === 'ZodEmail';
}
function isZodUrl(schema) {
    return schema.constructor.name === 'ZodURL';
}
function isZodTuple(schema) {
    return schema.constructor.name === 'ZodTuple';
}
//# sourceMappingURL=zodToNango.js.map