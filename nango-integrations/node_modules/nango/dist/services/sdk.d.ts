import { Nango } from '@nangohq/node';
import { NangoActionBase, NangoSyncBase } from '@nangohq/runner-sdk';
import type { DryRunService } from './dryrun.service.js';
import type { ProxyConfiguration } from '@nangohq/runner-sdk';
import type { GetPublicConnection, Metadata, NangoProps } from '@nangohq/types';
import type { AxiosResponse } from 'axios';
export declare class NangoActionCLI extends NangoActionBase {
    nango: Nango;
    dryRunService: DryRunService;
    dryRun: boolean;
    constructor(props: NangoProps, cliProps: {
        dryRunService: DryRunService;
    });
    proxy<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    log(...args: [...any]): void;
    triggerSync(_providerConfigKey: string, connectionId: string, sync: string | {
        name: string;
        variant: string;
    }, _syncMode?: unknown): Promise<void | string>;
    startSync(_providerConfigKey: string, _syncs: (string | {
        name: string;
        variant: string;
    })[], _connectionId?: string): Promise<void>;
    tryAcquireLock(_props: {
        key: string;
        ttlMs: number;
    }): Promise<boolean>;
    releaseLock(_props: {
        key: string;
    }): Promise<boolean>;
    releaseAllLocks(): Promise<void>;
    protected showLoggerLevelWarning: () => void;
}
export declare class NangoSyncCLI extends NangoSyncBase {
    nango: Nango;
    dryRunService: DryRunService;
    dryRun: boolean;
    logMessages: {
        counts: {
            updated: number;
            added: number;
            deleted: number;
        };
        messages: unknown[];
    };
    rawSaveOutput: Map<string, unknown[]>;
    rawDeleteOutput: Map<string, unknown[]>;
    stubbedMetadata?: Metadata | undefined;
    constructor(props: NangoProps, cliProps: {
        stubbedMetadata?: Metadata | undefined;
        dryRunService: DryRunService;
    });
    proxy: <T = any>(config: ProxyConfiguration) => Promise<AxiosResponse<T>>;
    log: (...args: [...any]) => void;
    triggerSync: (_providerConfigKey: string, connectionId: string, sync: string | {
        name: string;
        variant: string;
    }, _syncMode?: unknown) => Promise<void | string>;
    startSync: (_providerConfigKey: string, _syncs: (string | {
        name: string;
        variant: string;
    })[], _connectionId?: string) => Promise<void>;
    tryAcquireLock: (_props: {
        key: string;
        ttlMs: number;
    }) => Promise<boolean>;
    releaseLock: (_props: {
        key: string;
    }) => Promise<boolean>;
    releaseAllLocks: () => Promise<void>;
    protected showLoggerLevelWarning: () => void;
    batchSave<T extends object>(results: T[], model: string): boolean;
    batchDelete<T extends object>(results: T[], model: string): boolean;
    batchUpdate<T extends object>(results: T[], model: string): boolean;
    getMetadata<TMetadata = Metadata>(): Promise<TMetadata>;
    getConnection(providerConfigKeyOverride?: string, connectionIdOverride?: string): Promise<GetPublicConnection['Success']>;
    getRecordsByIds<K = string | number, T = any>(ids: K[], model: string): Promise<Map<K, T>>;
    setMergingStrategy(_merging: {
        strategy: 'ignore_if_modified_after' | 'override';
    }, _model: string): Promise<void>;
    deleteRecordsFromPreviousExecutions(_model: string): Promise<{
        deletedKeys: string[];
    }>;
}
