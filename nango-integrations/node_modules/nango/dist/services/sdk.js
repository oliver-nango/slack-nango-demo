import { isAxiosError } from 'axios';
import chalk from 'chalk';
import { Nango } from '@nangohq/node';
import { BASE_VARIANT, InvalidRecordSDKError, NangoActionBase, NangoSyncBase } from '@nangohq/runner-sdk';
const logLevelToLogger = {
    info: 'info',
    debug: 'debug',
    error: 'error',
    warn: 'warn',
    http: 'info',
    verbose: 'debug',
    silly: 'debug'
};
const logLevelToColor = {
    info: 'white',
    debug: 'gray',
    error: 'red',
    warn: 'yellow'
};
function showLoggerLevelWarning() {
    // only show it once
    let called = false;
    return () => {
        if (!called) {
            called = true;
            console.log(chalk.yellow('Note: In Nango Cloud, only logs with level "warn" or "error" will be shown by default. Learn more: https://nango.dev/docs/reference/functions#logging'));
        }
    };
}
export class NangoActionCLI extends NangoActionBase {
    nango;
    dryRunService;
    dryRun = true;
    constructor(props, cliProps) {
        super(props);
        this.dryRunService = cliProps.dryRunService;
        this.nango = new Nango({ isSync: false, dryRun: true, ...props }, getAxiosSettings(props));
    }
    async proxy(config) {
        if (!config.method) {
            config.method = 'GET';
        }
        const res = await this.nango.proxy(config);
        if (isAxiosError(res)) {
            throw res;
        }
        return res;
    }
    log(...args) {
        if (args.length === 0) {
            return;
        }
        this.showLoggerLevelWarning();
        const lastArg = args[args.length - 1];
        const isUserDefinedLevel = (object) => {
            return lastArg && typeof lastArg === 'object' && 'level' in object;
        };
        const userDefinedLevel = isUserDefinedLevel(lastArg) ? lastArg : undefined;
        if (userDefinedLevel) {
            args.pop();
        }
        const level = userDefinedLevel?.level ?? 'info';
        const logLevel = logLevelToLogger[level] ?? 'info';
        if (!this.shouldLog(logLevel)) {
            return;
        }
        if (args.length > 1 && 'type' in args[1] && args[1].type === 'http') {
            console[logLevel](args[0], { status: args[1]?.response?.code || 'xxx' });
        }
        else {
            console[logLevel](chalk[logLevelToColor[logLevel]](...args));
        }
    }
    triggerSync(_providerConfigKey, connectionId, sync, _syncMode) {
        const syncArgs = typeof sync === 'string' ? { sync } : { sync: sync.name, variant: sync.variant };
        return this.dryRunService.run({
            ...syncArgs,
            connectionId,
            autoConfirm: true,
            debug: false
        });
    }
    startSync(_providerConfigKey, _syncs, _connectionId) {
        this.log(`This has no effect but on a remote Nango instance would start a schedule`);
        return Promise.resolve();
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async tryAcquireLock(_props) {
        // Not applicable to CLI
        return true;
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async releaseLock(_props) {
        // Not applicable to CLI
        return true;
    }
    async releaseAllLocks() {
        // Not applicable to CLI
    }
    showLoggerLevelWarning = showLoggerLevelWarning();
}
export class NangoSyncCLI extends NangoSyncBase {
    nango;
    dryRunService;
    dryRun = true;
    logMessages = {
        counts: { updated: 0, added: 0, deleted: 0 },
        messages: []
    };
    rawSaveOutput = new Map();
    rawDeleteOutput = new Map();
    stubbedMetadata = undefined;
    constructor(props, cliProps) {
        super(props);
        if (cliProps.stubbedMetadata) {
            this.stubbedMetadata = cliProps.stubbedMetadata;
        }
        this.dryRunService = cliProps.dryRunService;
        this.nango = new Nango({ isSync: true, dryRun: true, ...props }, getAxiosSettings(props));
    }
    // Can't double extends
    proxy = NangoActionCLI['prototype']['proxy'];
    log = NangoActionCLI['prototype']['log'];
    triggerSync = NangoActionCLI['prototype']['triggerSync'];
    startSync = NangoActionCLI['prototype']['startSync'];
    tryAcquireLock = NangoActionCLI['prototype']['tryAcquireLock'];
    releaseLock = NangoActionCLI['prototype']['releaseLock'];
    releaseAllLocks = NangoActionCLI['prototype']['releaseAllLocks'];
    showLoggerLevelWarning = showLoggerLevelWarning();
    batchSave(results, model) {
        if (!results || results.length === 0) {
            console.info('batchSave received an empty array. No records to save.');
            return true;
        }
        // Deduplicate results first before removing metadata keeping order and last occurrence
        const seenIds = new Set();
        const deduplicatedResults = [];
        for (let i = results.length - 1; i >= 0; i--) {
            const record = results[i];
            if (!seenIds.has(record.id)) {
                seenIds.add(record.id);
                deduplicatedResults.unshift(record);
            }
            else {
                console.warn(`batchSave detected duplicate records for ID: ${record.id}. Keeping the last occurrence.`);
            }
        }
        const resultsWithoutMetadata = this.removeMetadata(deduplicatedResults);
        // Validate records
        const hasErrors = this.validateRecords(model, resultsWithoutMetadata);
        if (hasErrors.length > 0) {
            this.log('Invalid record payload. Use `--validation` option to see the details', { level: 'warn' });
            if (this.runnerFlags?.validateSyncRecords) {
                throw new InvalidRecordSDKError({ ...hasErrors[0], model });
            }
        }
        this.logMessages?.messages.push(`A batch save call would save the following data to the ${model} model${this.variant === BASE_VARIANT ? `` : ` (variant: ${this.variant})`}:`);
        for (const msg of resultsWithoutMetadata) {
            this.logMessages?.messages.push(msg);
        }
        if (this.logMessages && this.logMessages.counts) {
            this.logMessages.counts.added = Number(this.logMessages.counts.added) + deduplicatedResults.length;
        }
        const modelFullName = this.modelFullName(model);
        if (this.rawSaveOutput) {
            if (!this.rawSaveOutput.has(modelFullName)) {
                this.rawSaveOutput.set(modelFullName, []);
            }
            this.rawSaveOutput.get(modelFullName)?.push(...deduplicatedResults);
        }
        return true;
    }
    batchDelete(results, model) {
        if (!results || results.length === 0) {
            console.info('batchDelete received an empty array. No records to delete.');
            return true;
        }
        const resultsWithoutMetadata = this.removeMetadata(results);
        this.logMessages?.messages.push(`A batch delete call would delete the following data:`);
        for (const msg of resultsWithoutMetadata) {
            this.logMessages?.messages.push(msg);
        }
        if (this.logMessages && this.logMessages.counts) {
            this.logMessages.counts.deleted = Number(this.logMessages.counts.deleted) + results.length;
        }
        const modelFullName = this.modelFullName(model);
        if (this.rawDeleteOutput) {
            if (!this.rawDeleteOutput.has(modelFullName)) {
                this.rawDeleteOutput.set(modelFullName, []);
            }
            this.rawDeleteOutput.get(modelFullName)?.push(...results);
        }
        return true;
    }
    batchUpdate(results, model) {
        if (!results || results.length === 0) {
            console.info('batchUpdate received an empty array. No records to update.');
            return true;
        }
        const resultsWithoutMetadata = this.removeMetadata(results);
        this.logMessages?.messages.push(`A batch update call would save the following data to the ${model} model${this.variant === BASE_VARIANT ? `` : ` (variant: ${this.variant})`}:`);
        for (const msg of resultsWithoutMetadata) {
            this.logMessages?.messages.push(msg);
        }
        if (this.logMessages && this.logMessages.counts) {
            this.logMessages.counts.updated = Number(this.logMessages.counts.updated) + results.length;
        }
        return true;
    }
    getMetadata() {
        if (this.stubbedMetadata) {
            return Promise.resolve(this.stubbedMetadata);
        }
        return super.getMetadata();
    }
    async getConnection(providerConfigKeyOverride, connectionIdOverride) {
        const fetchedConnection = await super.getConnection(providerConfigKeyOverride, connectionIdOverride);
        if (this.stubbedMetadata) {
            return { ...fetchedConnection, metadata: this.stubbedMetadata };
        }
        return fetchedConnection;
    }
    async getRecordsByIds(ids, model) {
        const objects = new Map();
        if (ids.length === 0) {
            return objects;
        }
        const externalIds = ids.map((id) => String(id).replaceAll('\x00', ''));
        const externalIdMap = new Map(ids.map((id) => [String(id), id]));
        let cursor = null;
        for (let i = 0; i < ids.length; i += 100) {
            const batchIds = externalIds.slice(i, i + 100);
            const props = {
                providerConfigKey: this.providerConfigKey,
                connectionId: this.connectionId,
                model: this.modelFullName(model),
                ids: batchIds
            };
            if (cursor) {
                props.cursor = cursor;
            }
            const response = await this.nango.listRecords(props);
            const batchRecords = response.records;
            cursor = response.next_cursor;
            for (const record of batchRecords) {
                const stringId = String(record.id);
                const realId = externalIdMap.get(stringId);
                if (realId !== undefined) {
                    objects.set(realId, record);
                }
            }
        }
        return objects;
    }
    async setMergingStrategy(_merging, _model) {
        // Not applicable to CLI
        return Promise.resolve();
    }
    async deleteRecordsFromPreviousExecutions(_model) {
        this.log(`This has no effect but on a remote Nango instance would delete records that were not added or updated during the current execution.`);
        return Promise.resolve({ deletedKeys: [] });
    }
}
function getAxiosSettings(props) {
    const axiosSettings = {
        userAgent: 'sdk'
    };
    if (props.axios?.response) {
        axiosSettings.interceptors = {
            response: {
                onFulfilled: props.axios.response.onFulfilled,
                onRejected: props.axios.response.onRejected
            }
        };
    }
    else {
        axiosSettings.interceptors = {
            response: {
                onFulfilled: (res) => {
                    logAPICall(res);
                    return res;
                },
                onRejected: (err) => {
                    logAPICall(err);
                    return err;
                }
            }
        };
    }
    return axiosSettings;
}
function logAPICall(res) {
    const method = res.config?.method?.toLocaleUpperCase(); // axios put it in lowercase
    if (isAxiosError(res)) {
        console.log(chalk.blue('http'), `[${chalk[res.status || 999 >= 400 ? 'red' : 'green'](res.status || 'xxx')}] ${method} ${res.config?.url}`);
        return;
    }
    console.log(chalk.blue('http'), `[${chalk[res.status >= 400 ? 'red' : 'green'](res.status)}] ${method} ${res.config.url}`);
}
//# sourceMappingURL=sdk.js.map